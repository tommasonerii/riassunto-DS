\documentclass[a4paper,12pt]{book}

% --- Pacchetti di base ---
\usepackage[utf8]{inputenc}      % per caratteri UTF-8
\usepackage[T1]{fontenc}         % migliore gestione caratteri
\usepackage[italian]{babel}      % lingua italiana
\usepackage{geometry}             % per margini
\geometry{a4paper, margin=2.5cm}

% --- Tipografia e matematica ---
\usepackage{amsmath, amssymb}
\usepackage{graphicx}             % per inserire immagini
\usepackage{hyperref}             % link cliccabili
\usepackage{setspace}             % per interlinea
\onehalfspacing                   % interlinea 1.5

% --- Info documento ---
\title{Titolo del libro o relazione}
\author{Il tuo nome}
\date{\today}

% --- Inizio documento ---
\begin{document}

\frontmatter      % (opzionale) numerazione romana: prefazione, indice, ecc.
\maketitle
\tableofcontents  % genera l'indice automatico

\mainmatter 

\chapter{Introduction to Distributed Systems}
\label{ch:introduction}

\section{What Is a Distributed System?}
A distributed system is a collection of independent computers that appears to its users as a single coherent system. The nodes coordinate by exchanging messages over a network to share resources, collaborate on tasks, and provide services that no single node would deliver effectively on its own. Examples range from web and cloud services, databases, and content delivery networks to IoT deployments and edge/vehicular platforms.

\paragraph{Why distribute?} Key motivations include scalable performance, high availability, geographic reach, cost efficiency, and organizational autonomy. Distribution also introduces fundamental challenges: partial failures, concurrency, unpredictable communication delays, heterogeneous components, and security risks.

\section{Goals and Design Principles}
\begin{itemize}
  \item \textbf{Resource sharing:} efficient, controlled access to hardware, data, and services across nodes.
  \item \textbf{Openness:} well-defined interfaces, use of standard protocols and formats, and ease of extension and integration.
  \item \textbf{Transparency:} hide distribution aspects where feasible (see below) to simplify use and programming.
  \item \textbf{Scalability:} maintain acceptable service as size, geographic span, or administrative domains grow.
  \item \textbf{Fault tolerance:} continue operation despite faults via redundancy, detection, and recovery.
  \item \textbf{Concurrency:} support safe parallelism and shared use without interference.
  \item \textbf{Security:} preserve confidentiality, integrity, and availability while enabling controlled sharing.
  \item \textbf{Performance/cost:} balance latency, throughput, utilization, and cost of ownership.
\end{itemize}

\subsection{Transparency Dimensions}
Common transparency types sought by middleware and system design:
\begin{itemize}
  \item \textbf{Access:} uniform operations to local and remote resources.
  \item \textbf{Location:} resource names independent of their network location.
  \item \textbf{Migration/Relocation:} resources and computations can move without breaking references.
  \item \textbf{Replication:} multiple replicas appear as one logical resource.
  \item \textbf{Concurrency:} coordinate simultaneous access without exposing conflicts.
  \item \textbf{Failure:} mask and recover from faults where possible.
  \item \textbf{Persistence:} long-lived state independent of process lifetimes.
\end{itemize}
Perfect transparency is rarely achievable; designs make trade-offs to preserve clarity, performance, and correctness.

\section{Key Challenges}
\begin{itemize}
  \item \textbf{Heterogeneity:} diverse hardware, OSes, languages, data formats, and networks.
  \item \textbf{Openness and interoperability:} evolving standards, versioning, and backward compatibility.
  \item \textbf{Security:} authentication, authorization, confidentiality, integrity, and secure key management.
  \item \textbf{Scalability:} avoiding bottlenecks and hotspots in algorithms, data, and control planes.
  \item \textbf{Partial failures:} components fail independently; systems must detect, isolate, and recover.
  \item \textbf{Concurrency and consistency:} race conditions, non-determinism, and data coherence across replicas.
  \item \textbf{Latency variability:} high, jittery delays; timeouts and retries complicate logic.
  \item \textbf{Naming and discovery:} stable identifiers, late binding, and dynamic membership.
\end{itemize}

\section{Architectural Styles (Overview)}
\begin{itemize}
  \item \textbf{Client--Server and Multi-Tier:} clients issue requests to services often split into presentation, application, and data tiers.
  \item \textbf{Peer-to-Peer:} nodes act as both clients and servers, emphasizing decentralization, self-organization, and robustness.
  \item \textbf{Service-Oriented / Microservices:} independently deployable services communicating via stable interfaces and often asynchronous messaging.
  \item \textbf{Data-Centric:} storage, caching, and streams as the backbone; computation moves to data when possible.
  \item \textbf{Edge/Fog and Cloud:} place computation near data sources for latency and privacy while leveraging cloud elasticity.
\end{itemize}
Architectures are frequently composed (e.g., microservices backed by replicated, sharded data stores served through an edge cache).

\section{Middleware}
Middleware provides reusable building blocks that bridge applications and the underlying network/OS, commonly offering naming, discovery, security, communication (RPC/RMI, messaging), transactions, state management, and monitoring. It aims to improve openness and transparency, and to encapsulate cross-cutting concerns.

\section{Performance and Scalability}
\subsection{Core Metrics}
\begin{itemize}
  \item \textbf{Latency} (response time) and \textbf{throughput} (work per unit time).
  \item \textbf{Utilization} of CPUs, storage, and network.
  \item \textbf{Availability} \(A = \tfrac{\text{MTBF}}{\text{MTBF}+\text{MTTR}}\) and \textbf{reliability} (probability of no failure over an interval).
\end{itemize}

\subsection{Scalability Axes and Techniques}
Scalability concerns \emph{size} (users, data, nodes), \emph{geography} (latency domains), and \emph{administration} (multi-tenancy, autonomy). Typical techniques:
\begin{itemize}
  \item \textbf{Distribution} and \textbf{partitioning/sharding} of state and work.
  \item \textbf{Replication} and \textbf{caching} for read scaling and availability.
  \item \textbf{Asynchrony} to hide latency and decouple producers/consumers.
  \item \textbf{Load balancing} and \textbf{elastic provisioning} to smooth hotspots.
  \item \textbf{Locality} optimizations: move compute to data; edge caching.
\end{itemize}
Each technique alters consistency guarantees, fault behavior, and cost; designs should make these trade-offs explicit.

\section{System and Failure Models}
\subsection{Timing Assumptions}
\begin{itemize}
  \item \textbf{Synchronous:} known bounds on processing, message delay, and clock drift.
  \item \textbf{Asynchronous:} no timing bounds; only eventual delivery assumptions (if any).
  \item \textbf{Partially synchronous:} practical middle ground; bounds hold after unknown stabilization time.
\end{itemize}

\subsection{Failure Types}
\begin{itemize}
  \item \textbf{Crash} and \textbf{omission} failures (lost sends/receives).
  \item \textbf{Timing} failures (too late/early with respect to assumed bounds).
  \item \textbf{Arbitrary (Byzantine)} behavior (incorrect or malicious behavior).
\end{itemize}
It is useful to distinguish \emph{fault} (cause), \emph{error} (erroneous state), and \emph{failure} (service deviates from spec). Communication channels can exhibit omission, reordering, duplication, and corruption; protocols must tolerate these.

\section{Security Fundamentals}
Designs should integrate:
\begin{itemize}
  \item \textbf{Authentication} and \textbf{authorization} with least privilege and auditability.
  \item \textbf{Confidentiality} and \textbf{integrity} via cryptographic protocols and secure key management.
  \item \textbf{Availability} through rate limiting, redundancy, and resilient operations.
\end{itemize}
Security interacts with performance and openness; early threat modeling avoids costly redesigns.

\section{Typical Trade-offs}
\begin{itemize}
  \item \textbf{Consistency vs. availability under partitions} (often discussed via CAP) and latency vs. freshness.
  \item \textbf{Transparency vs. control/efficiency:} hiding distribution can incur overhead or obscure failure modes.
  \item \textbf{Replication vs. cost/complexity:} improves reads and availability but complicates updates.
\end{itemize}

\section{Running Examples}
To ground concepts, keep in mind: a globally distributed key-value store, a content delivery network, and an IoT sensing platform. Each highlights naming, replication, failure handling, security, and scale.

\section{Chapter Summary}
Distributed systems coordinate independent nodes to present a unified, useful service at scale. Their design balances openness, transparency, scalability, and security while embracing failures and concurrency as the norm. Subsequent chapters detail processes and communication, naming and synchronization, consistency and replication, and fault-tolerant services.

